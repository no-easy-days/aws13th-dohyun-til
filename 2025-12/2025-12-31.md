# Python

## Function as First-class Citizen 
### first-class citizen
프로그래밍 언어 설계에서 first-class citizen이란, 보통 다른 개체들이 일반적으로 사용할 수 있는 모든 연산을 동일하게 지원하는 개체를 의미.
이런 연산에는 인자로 전달된다거나, 함수의 반환값이 된다거나, 변수에 할당될 수 있다는것도 포함

### first-class function
프로그래밍 언어가 first-class function을 가진다고 할때는, 그 언어가 함수를 일급 시민으로 취급한다는걸 의미.
즉, 그 언어는 함수를 다른 함수의 인자로 전달할 수 있고, 다른 함수의 반환값으로 돌려줄 수 있으며, 변수에 할당하거나 자료구조에 저장할 수 있음을 지원한다는 뜻이다.
first-class function은 함수형 프로그래밍에 필수적인 요소. 
이 스타일에서는 higer-order function의 사용이 표준적 관행이다.
하지만, 함수를 인자로 전달하거나 반환값으로 사용하는 과정에는 특정한 구현상의 어려움이 존재하는데, 
특히 nested function이나, annoymous function, non-local variable이 있으면 문제가 생김.
이러한 문제를 funarg문제라고 부른다.
- 문제가 생기는 최소 예제

(1) 중첩 함수 + 비지역 변수
```
function outer() {
    int x = 10;

    function inner() {
        return x;
    }

    return inner;
}
```
여기서:
inner는 x를 사용함 (비지역 변수)
inner가 반환됨 → outer() 실행이 끝난 뒤에도 inner는 살아 있음

(2) 호출 시점의 메모리 상태

일반적인 함수 호출 모델에서는:
outer()의 지역 변수 x는 **스택(stack)**에 저장
outer()가 종료되면 → 스택 프레임 제거
x는 사라짐
그런데
```
inner()  ← 나중에 호출됨
   └── x 를 참조하려고 함
```
이미 x는 메모리에서 사라짐
→ dangling reference, 정의되지 않은 동작
 이게 바로 funarg 문제다.
 이를 해결하기 위해 함수는 단순한 코드 포인터가 아닌 정의 시점의 환경을 포함하는 클로저로 구현되어야 하고, 클로저의 동적 수명 관리를 위해 가비지 컬렉션이 필수적이다.


- 단순한 “함수 포인터”로는 왜 안 되는가?

C 같은 언어에서 함수는 보통 이렇게 취급:
함수 포인터 = "실행 코드의 시작 주소"

즉: 함수 포인터는 코드만 가리킴
함수가 어떤 환경에서 정의되었는지는 전혀 모름

문제점
```
int (*f)();  // 함수 포인터
```
이 포인터에는:

x = 10이라는 정보 없음
outer의 지역 변수 환경 정보 없음
비지역 변수 참조를 해결할 수 없음

- 해결책: 클로저(Closure)

(1) 클로저의 정의
**클로저(closure)**란:
함수 코드 + 그 함수가 정의될 당시의 환경(environment)을 함께 묶은 객체.
수식으로 쓰면:
```
Closure = (Function Code, Lexical Environment)
```

(2) 다시 예제로 보면
```
function outer() {
    int x = 10;

    function inner() {
        return x;
    }

    return inner;
}
```
outer()가 inner를 반환할 때 실제로 반환되는 것은:
```
closure {
    code: inner 함수의 코드
    env : { x → 10 }
}
```

즉 inner는 단순한 함수가 아니라 자기만의 변수 캡처 환경을 들고 다님

(3) 그래서 “함수 참조를 포인터가 아닌 클로저로 처리”

문장에서 말하는 핵심:
“일급 함수 + 어휘적 스코핑을 제대로 지원하려면 함수 참조는 코드 주소만 가진 포인터가 아니라 환경까지 포함한 클로저 객체여야 한다.”

- 그런데 왜 가비지 컬렉션이 필수가 되는가?

여기서 중요한 구현 문제가 등장
(1) 클로저의 환경은 어디에 저장해야 하나?
스택 ❌ → 함수 종료 시 사라짐
전역 ❌ → 범위/동시성 문제

**힙(heap)**에 저장해야 함
```
Heap:
  ┌──────────────┐
  │ closure      │
  │  - code ptr  │
  │  - env ptr ──┼──▶ { x = 10 }
  └──────────────┘
```
(2) 그럼 언제 이 메모리를 해제할까?

문제:
클로저는 언제까지 살아 있을지 알 수 없음
다른 함수에 전달될 수도 있고, 자료구조에 저장될 수도 있음

```
(define f (outer)); f는 언제 쓰일지 모름
```
수동으로 free() 호출?
사용 중 해제 위험
참조 추적 매우 어려움

(3) 그래서 가비지 컬렉션이 필요
**가비지 컬렉션(GC)**은:
더 이상 참조되지 않는 클로저와 환경을 자동으로 추적하여 메모리에서 제거

즉: 
클로저의 생명주기 = 동적

명시적 해제 불가능
→ GC 없이는 안전한 구현이 사실상 불가능

### higher order function
고차 함수는 다음 중 하나 이상을 수행하는 함수를 말한다.
다른 함수를 인자로 받으며, 함수를 반환.
파이썬의 내장 함수인 map(), filter(), sorted() 등이 대표적인 고차 함수.

아래와 같은 순서로 이루어진다.
```
First-class function
        
        ↓ (가능해짐)
        
Higher-order function
        
        ↓ (일반화된 스타일)

Functional programming idioms
```

## Decorator
(1) 정의
**파이썬 데코레이터(decorator)**란:

함수를 입력으로 받아, 그 함수를 감싼(wrap) 새로운 함수를 반환하는 함수

```
def my_decorator(func):
    def wrapper():
        print("before")
        func()
        print("after")
    return wrapper
```
사용:

```
@my_decorator
def hello():
    print("hello")
```
이는 문법적으로 다음과 완전히 동일:

```
hello = my_decorator(hello)
```
이 한 줄이 모든 개념의 핵심.

2. 데코레이터가 성립하려면 필요한 조건들

이 한 줄을 다시:
```
hello = my_decorator(hello)
```
여기서 암묵적으로 요구되는 언어 능력은:
함수가 인자로 전달됨.
함수가 반환값이 됨.
반환된 함수가 변수에 재할당됨.

즉:
Python의 함수는 first-class function

3. 데코레이터 내부: 클로저가 필수인 이유

위 예제에서 wrapper는 다음을 참조:
```
func   # 외부 함수 my_decorator의 지역 변수
```
이건 비지역 변수(non-local variable).
```
def my_decorator(func):   # func는 여기 지역
    def wrapper():        # wrapper는 func를 사용
        func()
```
즉:

wrapper는 func를 캡처
wrapper가 반환된 뒤에도 func는 살아 있어야 함

이 순간 클로저가 생성.
```
closure = {
  code: wrapper,
  env: { func: <hello 함수 객체> }
}
```
4. 데코레이터 = higher-order function + closure

- 가장 기본적인 형태
```
def decorator(func):
    def wrapper(*args, **kwargs):
        print("before")
        result = func(*args, **kwargs)
        print("after")
        return result
    return wrapper
```

여기서 정확한 관계를 정리하면:

데코레이터는:
higher-order function이다 ✔
반환값으로 클로저를 생성한다 ✔
funarg 문제를 언어가 해결해줬기 때문에 안전하다 ✔

즉:
데코레이터는 higher-order function의 실전 응용이며, 클로저 없이는 구현 불가능하다.

5. 왜 이게 funarg 문제의 “정답 사례”인가?

데코레이터가 없다면 생각해보자.
```
@my_decorator
def hello():
    print("hello")
```

my_decorator 실행 종료

func는 원래 지역 변수
그런데:
wrapper는 계속 func를 사용

만약 Python이:
클로저를 지원하지 않았다면, func는 사라졌을 것

❌ 데코레이터 작동 불가
❌ higher-order function 불가

6. GC와의 연결
데코레이터가 만드는 객체 구조
```
hello ──▶ wrapper (function object)
              │
              └── env: func ──▶ original hello function

``` 
함수 객체들
환경 객체들
서로 참조하는 그래프

이건 정적 수명 분석 불가능
그래서 Python은: 모든 함수/클로저를 힙 객체로 관리
**GC(참조 카운팅 + 순환 GC)**로 자동 해제
즉:
데코레이터는 GC가 없으면 안전하게 구현될 수 없다.
데코레이터 어노테이션은 함수 정의 직후에 데코레이터 함수를 호출하여, 기존 함수 객체를 감싼 새로운 함수로 이름 바인딩을 재설정함으로써, 원본 코드를 수정하지 않고 호출 경로에 기능을 삽입한다.

------------
```
First-class function
        ↓
Higher-order function
        ↓
(funarg problem 발생)
        ↓
Closure
        ↓
Garbage Collection
        ↓
Decorator, map/filter, callback, middleware, AOP
```
